<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="372" />
    <option name="newTranslationDialogWidth" value="643" />
    <option name="newTranslationDialogX" value="595" />
    <option name="newTranslationDialogY" value="-738" />
    <histories>
      <item value="Quits the handler thread's looper. &lt;p&gt; Causes the handler thread's looper to terminate without processing any more messages in the message queue. &lt;p&gt;&lt;p&gt; Any attempt to post messages to the queue after the looper is asked to quit will fail. For example, the {@link HandlersendMessage(Message)} method will return false. &lt;p&gt;&lt;p class=&quot;note&quot;&gt; Using this method may be unsafe because some messages may not be delivered before the looper terminates. Consider using {@link quitSafely} instead to ensure that all pending work is completed in an orderly manner. &lt;p&gt; @return True if the looper looper has been asked to quit or false if the thread had not yet started running. @see quitSafely" />
      <item value="Remove a previously registered death notification. The recipient will no longer be called if this object dies. @return {@code true} if the &lt;var&gt;recipient&lt;var&gt; is successfully unlinked, assuring you that its {@link DeathRecipientbinderDied DeathRecipient.binderDied()} method will not be called; {@code false} if the target IBinder has already died, meaning the method has been (or soon will be) called. @throws java.util.NoSuchElementException if the given &lt;var&gt;recipient&lt;var&gt; has not been registered with the IBinder, and the IBinder is still alive. Note that if the &lt;var&gt;recipient&lt;var&gt; was never registered, but the IBinder has already died, then this exception will &lt;em&gt;not&lt;em&gt; be thrown, and you will receive a false return value instead." />
      <item value="Interface for receiving a callback when the process hosting an IBinder has gone away." />
      <item value="Register the recipient for a notification if this binder goes away. If this binder object unexpectedly goes away (typically because its hosting process has been killed), then the given {@link DeathRecipient}'s {@link DeathRecipientbinderDied DeathRecipient.binderDied()} method will be called. &lt;p&gt;You will only receive death notifications for remote binders, as local binders by definition can't die without you dying as well. @throws RemoteException if the target IBinder's process has already died." />
      <item value="Old version of {@link onCallbackDied(E, Object)} that does not provide a cookie." />
      <item value="Return any cookie associated with a currently registered callback. Note that this is not the same as getBroadcastCookie(int) and should not be used interchangeably with it. This method returns the current cookie registered at the given index, not the current broadcast state. This means that it is not itself thread-safe: any call to register(E) or unregister(E) will change these indices, so you must do your own thread safety between these to protect from such changes.&#10;&#10;" />
      <item value="Flag unusual case that could be caused by a leak. b36778087" />
      <item value="Returns the number of registered callbacks. Note that the number of registered callbacks may differ from the value returned by {@link beginBroadcast()} since the former returns the number of callbacks registered at the time of the call and the second the number of callback to which the broadcast will be delivered. &lt;p&gt; This function is useful to decide whether to schedule a broadcast if this requires doing some work which otherwise would not be performed." />
      <item value="Return a currently registered callback. Note that this is &lt;em&gt;not&lt;em&gt; the same as {@link getBroadcastItem} and should not be used interchangeably with it. This method returns the registered callback at the given index, not the current broadcast state. This means that it is not itself thread-safe: any call to {@link register} or {@link unregister} will change these indices, so you must do your own thread safety between these to protect from such changes. @param index Index of which callback registration to return, from 0 to {@link getRegisteredCallbackCount()} - 1. @return Returns whatever callback is associated with this index, or null if {@link kill()} has been called." />
      <item value="Return any cookie associated with a currently registered callback. Note that this is &lt;em&gt;not&lt;em&gt; the same as {@link getBroadcastCookie} and should not be used interchangeably with it. This method returns the current cookie registered at the given index, not the current broadcast state. This means that it is not itself thread-safe: any call to {@link register} or {@link unregister} will change these indices, so you must do your own thread safety between these to protect from such changes. @param index Index of which registration cookie to return, from 0 to {@link getRegisteredCallbackCount()} - 1. @return Returns whatever cookie object is associated with this index, or null if" />
      <item value="Performs {@code action} for each cookie associated with a callback, calling {@link beginBroadcast()}{@link finishBroadcast()} beforeafter looping" />
      <item value="Performs {@code action} on each callback, calling {@link beginBroadcast()}{@link finishBroadcast()} beforeafter looping" />
      <item value="Clean up the state of a broadcast previously initiated by calling {@link beginBroadcast}. This must always be called when you are done with a broadcast." />
      <item value="Retrieve an item in the active broadcast that was previously started with {@link beginBroadcast}. This can &lt;em&gt;only&lt;em&gt; be called after the broadcast is started, and its data is no longer valid after calling {@link finishBroadcast}. &lt;p&gt;Note that it is possible for the process of one of the returned callbacks to go away before you call it, so you will need to catch {@link RemoteException} when calling on to the returned object. The callback list itself, however, will take care of unregistering these objects once it detects that it is no longer valid, so you can handle such an exception by simply ignoring it. @param index Which of the registered callbacks you would like to retrieve. Ranges from 0 to 1-{@link beginBroadcast}. @return Returns the callback interface that you can call. This will always be non-null." />
      <item value="Prepare to start making calls to the currently registered callbacks. This creates a copy of the callback list, which you can retrieve items from using {@link getBroadcastItem}. Note that only one broadcast can be active at a time, so you must be sure to always call this from the same thread (usually by scheduling with {@link Handler}) or do your own synchronization. You must call {@link finishBroadcast} when done. &lt;p&gt;A typical loop delivering a broadcast looks like this: &lt;pre&gt; int i = callbacks.beginBroadcast(); while (i &amp;gt; 0) { i--; try { callbacks.getBroadcastItem(i).somethingHappened(); } catch (RemoteException e) { The RemoteCallbackList will take care of removing the dead object for us. } } callbacks.finishBroadcast();&lt;pre&gt; @return Returns the number of callbacks in the broadcast, to be used with {@link getBroadcastItem} to determine the range of indices you can supply." />
      <item value="Called when the process hosting a callback in the list has gone away. The default implementation calls {@link onCallbackDied(E)} for backwards compatibility. @param callback The callback whose process has died. Note that, since its process has died, you can not make any calls on to this interface. You can, however, retrieve its IBinder and compare it with another IBinder to see if it is the same object. @param cookie The cookie object original provided to {@link register(E, Object)}" />
      <item value="Disable this callback list. All registered callbacks are unregistered, and the list is disabled so that future calls to {@link register} will fail. This should be used when a Service is stopping, to prevent clients from registering callbacks after it is stopped." />
      <item value="Remove from the list a callback that was previously added with {@link register}. This uses the {@link IInterfaceasBinder callback.asBinder()} object to correctly find the previous registration. Registrations are not counted; a single unregister call will remove a callback after any number calls to {@link register} for it. @param callback The callback to be removed from the list. Passing null here will cause a NullPointerException, so you will generally want to check for null before calling. @return Returns true if the callback was found and unregistered. Returns false if the given callback was not found on the list." />
      <item value="Add a new callback to the list. This callback will remain in the list until a corresponding call to {@link unregister} or its hosting process goes away. If the callback was already registered (determined by checking to see if the {@link IInterfaceasBinder callback.asBinder()} object is already in the list), then it will be left as-is. Registrations are not counted; a single call to {@link unregister} will remove a callback after any number calls to register it. @param callback The callback interface to be added to the list. Must not be null -- passing null here will cause a NullPointerException. Most services will want to check for null before calling this with an object given from a client, so that clients can't crash the service with bad data. @param cookie Optional additional data to be associated with this callback. @return Returns true if the callback was successfully added to the list. Returns false if it was not added, either because {@link kill} had previously been called or the callback's process has gone away." />
      <item value="Simple version of {@link RemoteCallbackListregister(E, Object)} that does not take a cookie object." />
      <item value="Takes care of the grunt work of maintaining a list of remote interfaces, typically for the use of performing callbacks from a {@link android.app.Service} to its clients. In particular, this: &lt;ul&gt; &lt;li&gt; Keeps track of a set of registered {@link IInterface} callbacks, taking care to identify them through their underlying unique {@link IBinder} (by calling {@link IInterfaceasBinder IInterface.asBinder()}. &lt;li&gt; Attaches a {@link IBinder.DeathRecipient IBinder.DeathRecipient} to each registered interface, so that it can be cleaned out of the list if its process goes away. &lt;li&gt; Performs locking of the underlying list of interfaces to deal with multithreaded incoming calls, and a thread-safe way to iterate over a snapshot of the list without holding its lock. &lt;ul&gt; &lt;p&gt;To use this class, simply create a single instance along with your service, and call its {@link register} and {@link unregister} methods as client register and unregister with your service. To call back on to the registered clients, use {@link beginBroadcast}, {@link getBroadcastItem}, and {@link finishBroadcast}. &lt;p&gt;If a registered callback's process goes away, this class will take care of automatically removing it from the list. If you want to do additional work in this situation, you can create a subclass that implements the {@link onCallbackDied} method." />
      <item value="非灰度用户" />
      <item value="非hui" />
      <item value="非会滴" />
      <item value="非" />
      <item value="非hi" />
      <item value="飞灰度" />
      <item value="grey scale" />
      <item value="Starts this service to perform action Foo with the given parameters. If the service is already performing a task this action will be queued." />
      <item value="Prepare to start making calls to the currently registered callbacks. This creates a copy of the callback list, which you can retrieve items from using {@link getBroadcastItem}. Note that only one broadcast can be active at a time, so you must be sure to always call this from the same thread (usually by scheduling with {@link Handler}) or do your own synchronization. You must call {@link finishBroadcast} when done." />
      <item value="Returns the number of callbacks in the broadcast, to be used with {@link getBroadcastItem} to determine the range of indices you can supply." />
      <item value="remote: select password from account_external_ids where external_id = &quot;username:qinzhan&quot; remote: Branch refs/heads/feature_changeDumpTime_TargetUser_threshold: remote: You need 'Push' rights with the 'Force Push' remote: flag set to delete references. remote: User: qinzhan remote: Please read the documentation and contact an administrator remote: if you feel the configuration is incorrect remote: remote: Processing changes: refs: 1 remote: Processing changes: refs: 1, done failed to push some refs to 'ssh://qinzhan@gerrit.client.weibo.cn:29419/Weibo-CMW/AndroidPhone/Support/Aqts'" />
      <item value="emote: select password from account_external_ids where external_id = &quot;username:qinzhan&quot; remote: Branch refs/heads/feature_changeDumpTime_TargetUser_threshold: remote: You need 'Push' rights with the 'Force Push' remote: flag set to delete references. remote: User: qinzhan remote: Please read the documentation and contact an administrator remote: if you feel the configuration is incorrect remote: remote: Processing changes: refs: 1 remote: Processing changes: refs: 1, done failed to push some refs to 'ssh://qinzhan@gerrit.client.weibo.cn:29419/Weibo-CMW/AndroidPhone/Support/Aqts'" />
      <item value="修改版本dump次数和用户身份的检查条件以及触发阈值发生dump时的流程。" />
      <item value="interactive rebase in progress; onto c19d06d&#10;" />
      <item value="contains a path separator" />
      <item value="GRANTED" />
      <item value="OOM Config" />
      <item value="note:after enableDebug,enableSaveFile always true" />
      <item value="init Internal" />
      <item value="Aqts configuration builder,context can not be initialized with null" />
      <item value="Returns true if the string is null or 0-length. @param str the string to be examined @return true if str is null or zero length" />
      <item value="Returns true if the string is null or 0-length." />
      <item value="Try to initialize Aqts which had already been initialized before." />
      <item value="android.os.BinderProxy cannot be cast to com.peng.baidumusic_box.IService" />
      <item value="Caused by: java.lang.IllegalStateException: Not allowed to start service Intent { cmp=com.peng.baidumusic_box.MusicService }: app is in background uid UidRecord{c610711 u0a330 TPSL idle change:idle|cached procs:1 seq(0,0,0)}" />
      <item value="Constant to return from {@link onStartCommand}: if this service's process is killed while it is started (after returning from {@link onStartCommand}), and there are no new start intents to deliver to it, then take the service out of the started state and don't recreate until a future explicit call to {@link ContextstartService Context.startService(Intent)}. The service will not receive a {@link onStartCommand(Intent, int, int)} call with a null Intent because it will not be restarted if there are no pending Intents to deliver. &lt;p&gt;This mode makes sense for things that want to do some work as a result of being started, but can be stopped when under memory pressure and will explicit start themselves again later to do more work. An example of such a service would be one that polls for data from a server: it could schedule an alarm to poll every N minutes by having the alarm start its service. When its {@link onStartCommand} is called from the alarm, it schedules a new alarm for N minutes later, and spawns a thread to do its networking. If its process is killed while doing that check, the service will not be restarted until the alarm goes off." />
      <item value="Sets intent redelivery preferences. Usually called from the constructor with your preferred semantics. &lt;p&gt;If enabled is true, {@link onStartCommand(Intent, int, int)} will return {@link ServiceSTART_REDELIVER_INTENT}, so if this process dies before {@link onHandleIntent(Intent)} returns, the process will be restarted and the intent redelivered. If multiple Intents have been sent, only the most recent one is guaranteed to be redelivered. &lt;p&gt;If enabled is false (the default), {@link onStartCommand(Intent, int, int)} will return {@link ServiceSTART_NOT_STICKY}, and if the process dies, the Intent dies along with it." />
      <item value="get Feature Str State" />
      <item value="is Feature Enabled" />
    </histories>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1644378497630" />
  </component>
</application>