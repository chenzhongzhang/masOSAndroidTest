<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="566" />
    <option name="newTranslationDialogY" value="359" />
    <histories>
      <item value="Central Logger for all Shark artifacts. Set [logger] to change where these logs go." />
      <item value="How many bytes this reader has read from [source]. Can only increase." />
      <item value="Hprof is deprecated, and we offer partial backward compatibility. Any code that was previously using HprofReader directly now has to call [StreamingHprofReader.readerFor] or [HprofRandomAcccessReader.readerFor]" />
      <item value="Reads records in a Hprof source, one at a time with a specific position and size. Call [openReaderFor] to obtain a new instance." />
      <item value="Utility function to create a [OnHprofRecordTagListener] from the passed in [block] lambda instead of using the anonymous `object : OnHprofRecordTagListener` syntax." />
      <item value="Executes the given [block] function on this resource and then closes it down correctly whether an exception is thrown or not. @param block a function to process this [Closeable] resource. @return the result of [block] function invoked on this resource." />
      <item value="Opens a [CloseableHeapGraph] which you can use to navigate the indexed hprof and then close." />
      <item value="Searches the heap dump for leaking instances and then computes the shortest strong reference path from those instances to the GC roots." />
      <item value="filters" />
      <item value="@return the number of bytes read from the source" />
      <item value="Obtains a new source to read all hprof records from and calls [listener] back for each record that matches one of the provided [recordTags]." />
      <item value="First pass to count and correctly size arrays once and for all." />
      <item value="Creates a [StreamingHprofReader] that will call [StreamingSourceProvider.openStreamingSource] on every [readRecords] to obtain a [Source] to read the hprof data from. Before reading the hprof records, [StreamingHprofReader] will skip [HprofHeader.recordsPosition] bytes." />
      <item value="Reads the header of the provided [source] and returns it as a [HprofHeader]. This does not close the [source]." />
      <item value="Creates an in memory index of an hprof source provided by [hprofSourceProvider]." />
      <item value="A facility for opening a [CloseableHeapGraph] from a [File]. This first parses the file headers with [HprofHeader.parseHeaderOf], then indexes the file content with [HprofIndex.indexRecordsOf] and then opens a [CloseableHeapGraph] from the index, which you are responsible for closing after using." />
      <item value="Not included here: VmInternal: Ignoring because we've got 150K of it, but is this the right thing to do? What's VmInternal exactly? History does not go further than https:android.googlesource.complatformdalvik2+refsheadsmasterhitsrccomandroidhitHprofParser.java77 We should log to figure out what objects VmInternal points to. ReferenceCleanup: We used to keep it, but the name doesn't seem like it should create a leak. Unknown: it's unknown, should we care? We definitely don't care about those for leak finding: InternedString, Finalizing, Debugger, Unreachable" />
      <item value="ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern belongs to" />
      <item value="Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the licenseLICENSE.txt file." />
      <item value="build Leak Traces" />
      <item value="inspect Objects" />
      <item value="This first parses the file headers with [HprofHeader.parseHeaderOf], then indexes the file content with [HprofIndex.indexRecordsOf] and then opens a [CloseableHeapGraph] from the index, which" />
      <item value="A facility for opening a [CloseableHeapGraph] from a [File]." />
      <item value="A [HeapGraph] that reads from an Hprof file indexed by [HprofIndex]." />
      <item value="rebuild Reference Chain" />
      <item value="remove Duplicate Leak Objects" />
      <item value="filter" />
      <item value="filter reference instance count" />
      <item value="BUILDING LEAK TRACES" />
      <item value="INSPECTING OBJECTS" />
      <item value="FINDING PATHS TO RETAINED OBJECTS" />
      <item value="FINDING RETAINED OBJECTS" />
      <item value="Reports progress from the [HeapAnalyzer] as they occur, as [Step] values. This is a functional interface with which you can create a [OnAnalysisProgressListener] from a lambda." />
      <item value="LAST DUMP FILE STATUS" />
      <item value="MANUFACTURER" />
      <item value="use Full Trace" />
      <item value="use fulltrace" />
      <item value="Customize helper method" />
      <item value="detect" />
      <item value="helper methods." />
      <item value="An {@link IntentService} subclass for handling asynchronous task requests in a service on a separate handler thread." />
      <item value="An {@link IntentService} subclass for handling asynchronous task requests in" />
      <item value="a service on a separate handler thread" />
      <item value="TODO: Customize class - update intent actions, extra parameters and static" />
      <item value="Sets the minimum version of CMake required to build the native library. You should either keep the default value or only pass a value of 3.4.0 or lower." />
      <item value="Ground State Monitor" />
      <item value="report when ground state has changed" />
      <item value="WARNING RE INIT CONFIG" />
      <item value="observable object for the ground state monitor" />
      <item value="sdk init time,for recording run duration when crash happens" />
    </histories>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1629022881998" />
  </component>
</application>