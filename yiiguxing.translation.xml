<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogHeight" value="372" />
    <option name="newTranslationDialogWidth" value="643" />
    <option name="newTranslationDialogX" value="566" />
    <option name="newTranslationDialogY" value="364" />
    <histories>
      <item value="record Ad Jump Act Code" />
      <item value="Remit" />
      <item value="ad Scheme Verify Remit" />
      <item value="adextparams" />
      <item value="m Is Direct Open Ad Scheme" />
      <item value="DIALOG STYLE TRANSPARENT" />
      <item value="on Load Info Complete" />
      <item value="REMIT" />
      <item value="KEY AD SCHEME VERIFY REMIT" />
      <item value="The RecyclerView is not currently scrolling." />
      <item value="ppends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)" />
      <item value="Notify any registered observers that the item reflected at &lt;code&gt;position&lt;code&gt; has been newly inserted. The item previously at &lt;code&gt;position&lt;code&gt; is now at position &lt;code&gt;position + 1&lt;code&gt;. &lt;p&gt;This is a structural change event. Representations of other existing items in the data set are still considered up to date and will not be rebound, though their positions may be altered.&lt;p&gt; @param position Position of the newly inserted item in the data set @see notifyItemRangeInserted(int, int)" />
      <item value="horizontal" />
      <item value="Callback" />
      <item value="Call requires API level 29 (current min is 18): android.os.Parcel#readBoolean&#10;" />
      <item value="&#10;Call requires API level 29 (current min is 18): android.os.Parcel#readBoolean&#10;" />
      <item value="&#10;Call requires API level 29 (current min is 18): android.os.Parcel#readBoolean" />
      <item value="Read a boolean value from the parcel at the current dataPosition()." />
      <item value="存储" />
      <item value="Called when a connection to the Service has been lost. This typically happens when the process hosting the service has crashed or been killed. This does &lt;em&gt;not&lt;em&gt; remove the ServiceConnection itself -- this binding to the service will remain active, and you will receive a call to {@link onServiceConnected} when the Service is next running. @param name The concrete component name of the service whose connection has been lost." />
      <item value="Constant to return from {@link onStartCommand}: if this service's process is killed while it is started (after returning from {@link onStartCommand}), then leave it in the started state but don't retain this delivered intent. Later the system will try to re-create the service. Because it is in the started state, it will guarantee to call {@link onStartCommand} after creating the new service instance; if there are not any pending start commands to be delivered to the service, it will be called with a null intent object, so you must take care to check for this. &lt;p&gt;This mode makes sense for things that will be explicitly started and stopped to run for arbitrary periods of time, such as a service performing background music playback." />
      <item value="Called by the system every time a client explicitly starts the service by calling {@link android.content.ContextstartService}, providing the arguments it supplied and a unique integer token representing the start request. Do not call this method directly. &lt;p&gt;For backwards compatibility, the default implementation calls {@link onStart} and returns either {@link START_STICKY} or {@link START_STICKY_COMPATIBILITY}. &lt;p class=&quot;caution&quot;&gt;Note that the system calls this on your service's main thread. A service's main thread is the same thread where UI operations take place for Activities running in the same process. You should always avoid stalling the main thread's event loop. When doing long-running operations, network calls, or heavy disk IO, you should kick off a new thread, or use {@link android.os.AsyncTask}.&lt;p&gt; @param intent The Intent supplied to {@link android.content.ContextstartService}, as given. This may be null if the service is being restarted after its process has gone away, and it had previously returned anything except {@link START_STICKY_COMPATIBILITY}. @param flags Additional data about this start request. @param startId A unique integer representing this specific request to start. Use with {@link stopSelfResult(int)}. @return The return value indicates what semantics the system should use for the service's current started state. It may be one of the constants associated with the {@link START_CONTINUATION_MASK} bits. @see stopSelfResult(int)" />
      <item value="No implementation found for int com.sina.weibo.aqts.oom.dump.DumpNative.suspendVMAndFork(int) (tried Java_com_sina_weibo_aqts_oom_dump_DumpNative_suspendVMAndFork and Java_com_sina_weibo_aqts_oom_dump_DumpNative_suspendVMAndFork__I)" />
      <item value="No implementation found for int com.sina.weibo.aqts.oom.dump.DumpNative.suspendVMAndFork(int) (tried Java_com_sina_weibo_aqts_oom_dump_DumpNative_suspendVMAndFork and Java_com_sina_weibo_aqts_oom_dump_DumpNative_suspendVMAndFork__I) 2022-02-28 20:25:51.068 27320-27360com.sina.weibo.aqtsdemo EAndroidRuntime: FATAL EXCEPTION: Dump Thread" />
      <item value="Recycles a Message that may be in-use. Used internally by the MessageQueue and Looper when disposing of queued Message" />
      <item value="Constant to return from {@link onStartCommand}: if this service's process is killed while it is started (after returning from {@link onStartCommand}), and there are no new start intents to deliver to it, then take the service out of the started state and don't recreate until a future explicit call to {@link ContextstartService Context.startService(Intent)}. The service will not receive a {@link onStartCommand(Intent, int, int)} call with a null Intent because it will not be restarted if there are no pending Intents to deliver." />
      <item value="Creates an IntentService. Invoked by your subclass's constructor. @param name Used to name the worker thread, important only for debugging." />
      <item value="cannot be cast to" />
      <item value="store" />
      <item value="We can assume mPtr != 0 because mQuitting was previously false." />
      <item value="last dump retry times" />
      <item value="Quits the handler thread's looper. &lt;p&gt; Causes the handler thread's looper to terminate without processing any more messages in the message queue. &lt;p&gt;&lt;p&gt; Any attempt to post messages to the queue after the looper is asked to quit will fail. For example, the {@link HandlersendMessage(Message)} method will return false. &lt;p&gt;&lt;p class=&quot;note&quot;&gt; Using this method may be unsafe because some messages may not be delivered before the looper terminates. Consider using {@link quitSafely} instead to ensure that all pending work is completed in an orderly manner. &lt;p&gt; @return True if the looper looper has been asked to quit or false if the thread had not yet started running." />
      <item value="This method is called once every time the Application Zygote is started. It is normally started the first time an isolated service that uses it is started. The Application Zygote will be stopped when all isolated services that use it are stopped. @param appInfo The ApplicationInfo object belonging to the application" />
      <item value="This is the interface to be implemented for the class that is specified by the {@link android.R.styleableAndroidManifestApplication_zygotePreloadName android:zygotePreloadName} of the &amp;lt;application&amp;gt; tag. It is responsible for preloading application code and data, that will be shared by all isolated services that have the {@link android.R.styleableAndroidManifestService_useAppZygote android:useAppZygote} attribute of the &amp;lt;service&amp;gt; tag set to &lt;code&gt;true&lt;code&gt;. Note that implementations of this class must provide a default constructor with no arguments." />
      <item value="Quits the handler thread's looper. &lt;p&gt; Causes the handler thread's looper to terminate without processing any more messages in the message queue. &lt;p&gt;&lt;p&gt; Any attempt to post messages to the queue after the looper is asked to quit will fail. For example, the {@link HandlersendMessage(Message)} method will return false. &lt;p&gt;&lt;p class=&quot;note&quot;&gt; Using this method may be unsafe because some messages may not be delivered before the looper terminates. Consider using {@link quitSafely} instead to ensure that all pending work is completed in an orderly manner. &lt;p&gt; @return True if the looper looper has been asked to quit or false if the thread had not yet started running. @see quitSafely" />
      <item value="Remove a previously registered death notification. The recipient will no longer be called if this object dies. @return {@code true} if the &lt;var&gt;recipient&lt;var&gt; is successfully unlinked, assuring you that its {@link DeathRecipientbinderDied DeathRecipient.binderDied()} method will not be called; {@code false} if the target IBinder has already died, meaning the method has been (or soon will be) called. @throws java.util.NoSuchElementException if the given &lt;var&gt;recipient&lt;var&gt; has not been registered with the IBinder, and the IBinder is still alive. Note that if the &lt;var&gt;recipient&lt;var&gt; was never registered, but the IBinder has already died, then this exception will &lt;em&gt;not&lt;em&gt; be thrown, and you will receive a false return value instead." />
      <item value="Interface for receiving a callback when the process hosting an IBinder has gone away." />
      <item value="Register the recipient for a notification if this binder goes away. If this binder object unexpectedly goes away (typically because its hosting process has been killed), then the given {@link DeathRecipient}'s {@link DeathRecipientbinderDied DeathRecipient.binderDied()} method will be called. &lt;p&gt;You will only receive death notifications for remote binders, as local binders by definition can't die without you dying as well. @throws RemoteException if the target IBinder's process has already died." />
      <item value="Old version of {@link onCallbackDied(E, Object)} that does not provide a cookie." />
      <item value="Return any cookie associated with a currently registered callback. Note that this is not the same as getBroadcastCookie(int) and should not be used interchangeably with it. This method returns the current cookie registered at the given index, not the current broadcast state. This means that it is not itself thread-safe: any call to register(E) or unregister(E) will change these indices, so you must do your own thread safety between these to protect from such changes.&#10;&#10;" />
      <item value="Flag unusual case that could be caused by a leak. b36778087" />
      <item value="Returns the number of registered callbacks. Note that the number of registered callbacks may differ from the value returned by {@link beginBroadcast()} since the former returns the number of callbacks registered at the time of the call and the second the number of callback to which the broadcast will be delivered. &lt;p&gt; This function is useful to decide whether to schedule a broadcast if this requires doing some work which otherwise would not be performed." />
      <item value="Return a currently registered callback. Note that this is &lt;em&gt;not&lt;em&gt; the same as {@link getBroadcastItem} and should not be used interchangeably with it. This method returns the registered callback at the given index, not the current broadcast state. This means that it is not itself thread-safe: any call to {@link register} or {@link unregister} will change these indices, so you must do your own thread safety between these to protect from such changes. @param index Index of which callback registration to return, from 0 to {@link getRegisteredCallbackCount()} - 1. @return Returns whatever callback is associated with this index, or null if {@link kill()} has been called." />
      <item value="Return any cookie associated with a currently registered callback. Note that this is &lt;em&gt;not&lt;em&gt; the same as {@link getBroadcastCookie} and should not be used interchangeably with it. This method returns the current cookie registered at the given index, not the current broadcast state. This means that it is not itself thread-safe: any call to {@link register} or {@link unregister} will change these indices, so you must do your own thread safety between these to protect from such changes. @param index Index of which registration cookie to return, from 0 to {@link getRegisteredCallbackCount()} - 1. @return Returns whatever cookie object is associated with this index, or null if" />
      <item value="Performs {@code action} for each cookie associated with a callback, calling {@link beginBroadcast()}{@link finishBroadcast()} beforeafter looping" />
      <item value="Performs {@code action} on each callback, calling {@link beginBroadcast()}{@link finishBroadcast()} beforeafter looping" />
      <item value="Clean up the state of a broadcast previously initiated by calling {@link beginBroadcast}. This must always be called when you are done with a broadcast." />
      <item value="Retrieve an item in the active broadcast that was previously started with {@link beginBroadcast}. This can &lt;em&gt;only&lt;em&gt; be called after the broadcast is started, and its data is no longer valid after calling {@link finishBroadcast}. &lt;p&gt;Note that it is possible for the process of one of the returned callbacks to go away before you call it, so you will need to catch {@link RemoteException} when calling on to the returned object. The callback list itself, however, will take care of unregistering these objects once it detects that it is no longer valid, so you can handle such an exception by simply ignoring it. @param index Which of the registered callbacks you would like to retrieve. Ranges from 0 to 1-{@link beginBroadcast}. @return Returns the callback interface that you can call. This will always be non-null." />
      <item value="Prepare to start making calls to the currently registered callbacks. This creates a copy of the callback list, which you can retrieve items from using {@link getBroadcastItem}. Note that only one broadcast can be active at a time, so you must be sure to always call this from the same thread (usually by scheduling with {@link Handler}) or do your own synchronization. You must call {@link finishBroadcast} when done. &lt;p&gt;A typical loop delivering a broadcast looks like this: &lt;pre&gt; int i = callbacks.beginBroadcast(); while (i &amp;gt; 0) { i--; try { callbacks.getBroadcastItem(i).somethingHappened(); } catch (RemoteException e) { The RemoteCallbackList will take care of removing the dead object for us. } } callbacks.finishBroadcast();&lt;pre&gt; @return Returns the number of callbacks in the broadcast, to be used with {@link getBroadcastItem} to determine the range of indices you can supply." />
      <item value="Called when the process hosting a callback in the list has gone away. The default implementation calls {@link onCallbackDied(E)} for backwards compatibility. @param callback The callback whose process has died. Note that, since its process has died, you can not make any calls on to this interface. You can, however, retrieve its IBinder and compare it with another IBinder to see if it is the same object. @param cookie The cookie object original provided to {@link register(E, Object)}" />
    </histories>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1646652684336" />
  </component>
</application>