<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogHeight" value="372" />
    <option name="newTranslationDialogWidth" value="643" />
    <option name="newTranslationDialogX" value="566" />
    <option name="newTranslationDialogY" value="364" />
    <histories>
      <item value="Remit" />
      <item value="Ad Scheme Verify Result" />
      <item value="Ad Scheme Verify Params" />
      <item value="Do Verify Scheme Task" />
      <item value="Concurrent Manager" />
      <item value="Do Verify Scheme Task Running" />
      <item value="is Do Verify Scheme Task Running" />
      <item value="record Ad Click Action Log" />
      <item value="&lt;p&gt;&lt;strong&gt;Warning:&lt;strong&gt; Prior to Jelly Bean, this decoded the '+' character as '+' rather than ' '. @param key which will be encoded @throws UnsupportedOperationException if this isn't a hierarchical URI @throws NullPointerException if key is null @return the decoded value or null if no parameter is found" />
      <item value="Searches the query string for the first value with the given key." />
      <item value="record Ad Jump Act Code" />
      <item value="ad Scheme Verify Remit" />
      <item value="adextparams" />
      <item value="m Is Direct Open Ad Scheme" />
      <item value="DIALOG STYLE TRANSPARENT" />
      <item value="on Load Info Complete" />
      <item value="REMIT" />
      <item value="KEY AD SCHEME VERIFY REMIT" />
      <item value="The RecyclerView is not currently scrolling." />
      <item value="ppends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)" />
      <item value="Notify any registered observers that the item reflected at &lt;code&gt;position&lt;code&gt; has been newly inserted. The item previously at &lt;code&gt;position&lt;code&gt; is now at position &lt;code&gt;position + 1&lt;code&gt;. &lt;p&gt;This is a structural change event. Representations of other existing items in the data set are still considered up to date and will not be rebound, though their positions may be altered.&lt;p&gt; @param position Position of the newly inserted item in the data set @see notifyItemRangeInserted(int, int)" />
      <item value="horizontal" />
      <item value="Callback" />
      <item value="Call requires API level 29 (current min is 18): android.os.Parcel#readBoolean&#10;" />
      <item value="&#10;Call requires API level 29 (current min is 18): android.os.Parcel#readBoolean&#10;" />
      <item value="&#10;Call requires API level 29 (current min is 18): android.os.Parcel#readBoolean" />
      <item value="Read a boolean value from the parcel at the current dataPosition()." />
      <item value="存储" />
      <item value="Called when a connection to the Service has been lost. This typically happens when the process hosting the service has crashed or been killed. This does &lt;em&gt;not&lt;em&gt; remove the ServiceConnection itself -- this binding to the service will remain active, and you will receive a call to {@link onServiceConnected} when the Service is next running. @param name The concrete component name of the service whose connection has been lost." />
      <item value="Constant to return from {@link onStartCommand}: if this service's process is killed while it is started (after returning from {@link onStartCommand}), then leave it in the started state but don't retain this delivered intent. Later the system will try to re-create the service. Because it is in the started state, it will guarantee to call {@link onStartCommand} after creating the new service instance; if there are not any pending start commands to be delivered to the service, it will be called with a null intent object, so you must take care to check for this. &lt;p&gt;This mode makes sense for things that will be explicitly started and stopped to run for arbitrary periods of time, such as a service performing background music playback." />
      <item value="Called by the system every time a client explicitly starts the service by calling {@link android.content.ContextstartService}, providing the arguments it supplied and a unique integer token representing the start request. Do not call this method directly. &lt;p&gt;For backwards compatibility, the default implementation calls {@link onStart} and returns either {@link START_STICKY} or {@link START_STICKY_COMPATIBILITY}. &lt;p class=&quot;caution&quot;&gt;Note that the system calls this on your service's main thread. A service's main thread is the same thread where UI operations take place for Activities running in the same process. You should always avoid stalling the main thread's event loop. When doing long-running operations, network calls, or heavy disk IO, you should kick off a new thread, or use {@link android.os.AsyncTask}.&lt;p&gt; @param intent The Intent supplied to {@link android.content.ContextstartService}, as given. This may be null if the service is being restarted after its process has gone away, and it had previously returned anything except {@link START_STICKY_COMPATIBILITY}. @param flags Additional data about this start request. @param startId A unique integer representing this specific request to start. Use with {@link stopSelfResult(int)}. @return The return value indicates what semantics the system should use for the service's current started state. It may be one of the constants associated with the {@link START_CONTINUATION_MASK} bits. @see stopSelfResult(int)" />
      <item value="No implementation found for int com.sina.weibo.aqts.oom.dump.DumpNative.suspendVMAndFork(int) (tried Java_com_sina_weibo_aqts_oom_dump_DumpNative_suspendVMAndFork and Java_com_sina_weibo_aqts_oom_dump_DumpNative_suspendVMAndFork__I)" />
      <item value="No implementation found for int com.sina.weibo.aqts.oom.dump.DumpNative.suspendVMAndFork(int) (tried Java_com_sina_weibo_aqts_oom_dump_DumpNative_suspendVMAndFork and Java_com_sina_weibo_aqts_oom_dump_DumpNative_suspendVMAndFork__I) 2022-02-28 20:25:51.068 27320-27360com.sina.weibo.aqtsdemo EAndroidRuntime: FATAL EXCEPTION: Dump Thread" />
      <item value="Recycles a Message that may be in-use. Used internally by the MessageQueue and Looper when disposing of queued Message" />
      <item value="Constant to return from {@link onStartCommand}: if this service's process is killed while it is started (after returning from {@link onStartCommand}), and there are no new start intents to deliver to it, then take the service out of the started state and don't recreate until a future explicit call to {@link ContextstartService Context.startService(Intent)}. The service will not receive a {@link onStartCommand(Intent, int, int)} call with a null Intent because it will not be restarted if there are no pending Intents to deliver." />
      <item value="Creates an IntentService. Invoked by your subclass's constructor. @param name Used to name the worker thread, important only for debugging." />
      <item value="cannot be cast to" />
      <item value="store" />
      <item value="We can assume mPtr != 0 because mQuitting was previously false." />
      <item value="last dump retry times" />
      <item value="Quits the handler thread's looper. &lt;p&gt; Causes the handler thread's looper to terminate without processing any more messages in the message queue. &lt;p&gt;&lt;p&gt; Any attempt to post messages to the queue after the looper is asked to quit will fail. For example, the {@link HandlersendMessage(Message)} method will return false. &lt;p&gt;&lt;p class=&quot;note&quot;&gt; Using this method may be unsafe because some messages may not be delivered before the looper terminates. Consider using {@link quitSafely} instead to ensure that all pending work is completed in an orderly manner. &lt;p&gt; @return True if the looper looper has been asked to quit or false if the thread had not yet started running." />
      <item value="This method is called once every time the Application Zygote is started. It is normally started the first time an isolated service that uses it is started. The Application Zygote will be stopped when all isolated services that use it are stopped. @param appInfo The ApplicationInfo object belonging to the application" />
      <item value="This is the interface to be implemented for the class that is specified by the {@link android.R.styleableAndroidManifestApplication_zygotePreloadName android:zygotePreloadName} of the &amp;lt;application&amp;gt; tag. It is responsible for preloading application code and data, that will be shared by all isolated services that have the {@link android.R.styleableAndroidManifestService_useAppZygote android:useAppZygote} attribute of the &amp;lt;service&amp;gt; tag set to &lt;code&gt;true&lt;code&gt;. Note that implementations of this class must provide a default constructor with no arguments." />
      <item value="Quits the handler thread's looper. &lt;p&gt; Causes the handler thread's looper to terminate without processing any more messages in the message queue. &lt;p&gt;&lt;p&gt; Any attempt to post messages to the queue after the looper is asked to quit will fail. For example, the {@link HandlersendMessage(Message)} method will return false. &lt;p&gt;&lt;p class=&quot;note&quot;&gt; Using this method may be unsafe because some messages may not be delivered before the looper terminates. Consider using {@link quitSafely} instead to ensure that all pending work is completed in an orderly manner. &lt;p&gt; @return True if the looper looper has been asked to quit or false if the thread had not yet started running. @see quitSafely" />
      <item value="Remove a previously registered death notification. The recipient will no longer be called if this object dies. @return {@code true} if the &lt;var&gt;recipient&lt;var&gt; is successfully unlinked, assuring you that its {@link DeathRecipientbinderDied DeathRecipient.binderDied()} method will not be called; {@code false} if the target IBinder has already died, meaning the method has been (or soon will be) called. @throws java.util.NoSuchElementException if the given &lt;var&gt;recipient&lt;var&gt; has not been registered with the IBinder, and the IBinder is still alive. Note that if the &lt;var&gt;recipient&lt;var&gt; was never registered, but the IBinder has already died, then this exception will &lt;em&gt;not&lt;em&gt; be thrown, and you will receive a false return value instead." />
      <item value="Interface for receiving a callback when the process hosting an IBinder has gone away." />
      <item value="Register the recipient for a notification if this binder goes away. If this binder object unexpectedly goes away (typically because its hosting process has been killed), then the given {@link DeathRecipient}'s {@link DeathRecipientbinderDied DeathRecipient.binderDied()} method will be called. &lt;p&gt;You will only receive death notifications for remote binders, as local binders by definition can't die without you dying as well. @throws RemoteException if the target IBinder's process has already died." />
      <item value="Old version of {@link onCallbackDied(E, Object)} that does not provide a cookie." />
      <item value="Return any cookie associated with a currently registered callback. Note that this is not the same as getBroadcastCookie(int) and should not be used interchangeably with it. This method returns the current cookie registered at the given index, not the current broadcast state. This means that it is not itself thread-safe: any call to register(E) or unregister(E) will change these indices, so you must do your own thread safety between these to protect from such changes.&#10;&#10;" />
      <item value="Flag unusual case that could be caused by a leak. b36778087" />
    </histories>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1646652684336" />
  </component>
</application>