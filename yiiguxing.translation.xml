<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="372" />
    <option name="newTranslationDialogX" value="566" />
    <option name="newTranslationDialogY" value="359" />
    <histories>
      <item value="修改版本dump次数和用户身份的检查条件以及触发阈值发生dump时的流程。" />
      <item value="remote: select password from account_external_ids where external_id = &quot;username:qinzhan&quot; remote: Branch refs/heads/feature_changeDumpTime_TargetUser_threshold: remote: You need 'Push' rights with the 'Force Push' remote: flag set to delete references. remote: User: qinzhan remote: Please read the documentation and contact an administrator remote: if you feel the configuration is incorrect remote: remote: Processing changes: refs: 1 remote: Processing changes: refs: 1, done failed to push some refs to 'ssh://qinzhan@gerrit.client.weibo.cn:29419/Weibo-CMW/AndroidPhone/Support/Aqts'" />
      <item value="interactive rebase in progress; onto c19d06d&#10;" />
      <item value="contains a path separator" />
      <item value="GRANTED" />
      <item value="OOM Config" />
      <item value="note:after enableDebug,enableSaveFile always true" />
      <item value="init Internal" />
      <item value="Aqts configuration builder,context can not be initialized with null" />
      <item value="Returns true if the string is null or 0-length. @param str the string to be examined @return true if str is null or zero length" />
      <item value="Returns true if the string is null or 0-length." />
      <item value="Try to initialize Aqts which had already been initialized before." />
      <item value="android.os.BinderProxy cannot be cast to com.peng.baidumusic_box.IService" />
      <item value="Caused by: java.lang.IllegalStateException: Not allowed to start service Intent { cmp=com.peng.baidumusic_box.MusicService }: app is in background uid UidRecord{c610711 u0a330 TPSL idle change:idle|cached procs:1 seq(0,0,0)}" />
      <item value="Constant to return from {@link onStartCommand}: if this service's process is killed while it is started (after returning from {@link onStartCommand}), and there are no new start intents to deliver to it, then take the service out of the started state and don't recreate until a future explicit call to {@link ContextstartService Context.startService(Intent)}. The service will not receive a {@link onStartCommand(Intent, int, int)} call with a null Intent because it will not be restarted if there are no pending Intents to deliver. &lt;p&gt;This mode makes sense for things that want to do some work as a result of being started, but can be stopped when under memory pressure and will explicit start themselves again later to do more work. An example of such a service would be one that polls for data from a server: it could schedule an alarm to poll every N minutes by having the alarm start its service. When its {@link onStartCommand} is called from the alarm, it schedules a new alarm for N minutes later, and spawns a thread to do its networking. If its process is killed while doing that check, the service will not be restarted until the alarm goes off." />
      <item value="Sets intent redelivery preferences. Usually called from the constructor with your preferred semantics. &lt;p&gt;If enabled is true, {@link onStartCommand(Intent, int, int)} will return {@link ServiceSTART_REDELIVER_INTENT}, so if this process dies before {@link onHandleIntent(Intent)} returns, the process will be restarted and the intent redelivered. If multiple Intents have been sent, only the most recent one is guaranteed to be redelivered. &lt;p&gt;If enabled is false (the default), {@link onStartCommand(Intent, int, int)} will return {@link ServiceSTART_NOT_STICKY}, and if the process dies, the Intent dies along with it." />
      <item value="get Feature Str State" />
      <item value="is Feature Enabled" />
      <item value="Grey Scale Utils" />
      <item value="feature Valid" />
      <item value="update Config" />
      <item value="check If Sync Guard" />
      <item value="async Add Current Account" />
      <item value="sync Add Current Account" />
      <item value="Check Phone Bind Task" />
      <item value="async Add Account And Sync" />
      <item value="request Sync" />
      <item value="Declare any non-default types here with import statements" />
      <item value="scale" />
      <item value="do check is grey scale user" />
      <item value="get the external storage path" />
      <item value="when getDefaultDir happens err,return null" />
      <item value="Copyright (c) 2018-present, iQIYI, Inc. All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, andor sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE." />
      <item value="Inspired by https:github.comavs333Nougat_dlfunctions Parse ELF file based on proc&lt;pid&gt;mappings and store .dynsym、.dynstr、.symtab、.strtab information. It's much less effective than DlFcn::dlopen, do not use this in low memory state or high performance sensitive scenario! It's more powerful than DlFcn::dlopen which can only get symbols in .dynsym(GLOBAL), it can also get symbols in .symtab(LOCAL)." />
      <item value="Copyright (c) 2021-present, WeiBo, Inc. All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, andor sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE." />
      <item value="Copyright (c) 2021-present, WeiBo, Inc. All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, andor sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Created by wangyu on 21-1-20." />
      <item value="Weak reference objects, which do not prevent their referents from being made finalizable, finalized, and then reclaimed. Weak references are most often used to implement canonicalizing mappings. &lt;p&gt; Suppose that the garbage collector determines at a certain point in time that an object is &lt;a href=&quot;package-summary.htmlreachability&quot;&gt;weakly reachable&lt;a&gt;. At that time it will atomically clear all weak references to that object and all weak references to any other weakly-reachable objects from which that object is reachable through a chain of strong and soft references. At the same time it will declare all of the formerly weakly-reachable objects to be finalizable. At the same time or at some later time it will enqueue those newly-cleared weak references that are registered with reference queues." />
      <item value="Returns singleton class instance" />
      <item value="NORM PRIORITY" />
      <item value="Override to receive results delivered to this object. @param resultCode Arbitrary result code delivered by the sender, as defined by the sender. @param resultData Any additional data provided by the sender." />
      <item value="Inserts a Parcelable value into the mapping of this Bundle, replacing any existing value for the given key. Either key or value may be null." />
      <item value="if user does not set the upload process, main process will be set to the upload process" />
      <item value="is Foreground" />
      <item value="上次内存泄露检测的Hprof文件需要进行分析" />
      <item value="上次内存泄露检测的Hprof文件可再进行分析" />
      <item value="上一次内存泄露检测的Hprof文件不可再利用" />
      <item value="上一次的分析进程还在执行分析任务" />
      <item value="连接Service失败" />
      <item value="服务端判断Hprof文件可再利用,解绑服务，对该Hprof文件进行分析" />
      <item value="服务端判断Hprof文件不可再利用，解绑服务，直接返回，进行自己的dump" />
    </histories>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1642143745642" />
  </component>
</application>