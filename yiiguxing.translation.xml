<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="566" />
    <option name="newTranslationDialogY" value="359" />
    <histories>
      <item value="Unreachable" />
      <item value="Local variable" />
      <item value="Local variable to prevent the ref from becoming null after the null check" />
      <item value="artifacts" />
      <item value="Central Logger for all Shark artifacts. Set [logger] to change where these logs go." />
      <item value="ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern" />
      <item value="failed to get reply to handshake packet" />
      <item value="Logs a [Throwable] and debug message formatted with the passed in arguments." />
      <item value="Logs a debug message formatted with the passed in arguments." />
      <item value="Reads and discards {@code byteCount} bytes from this source. Throws an {@link java.io.EOFException} if the source is exhausted before the requested bytes can be skipped." />
      <item value="max Position" />
      <item value="type of the record" />
      <item value="The size in bytes for each value of that type." />
      <item value="Local ref optimizations" />
      <item value="Position" />
      <item value="How many bytes from the beginning of the file can we find the hprof records at. Version string, 0 delimiter (1 byte), identifier byte size int (4 bytes) ,timestamp long (8 bytes)" />
      <item value="Note:" />
      <item value="this performs two linear scans over arrays" />
      <item value="Not enough memory to allocate buffers for rehashing:" />
      <item value="number of bytes that follow and belong to this record" />
      <item value="This class is not thread safe, should be used from a single thread." />
      <item value="REFERENCE" />
      <item value="identifier Size" />
      <item value="A primitive type in the prof." />
      <item value="The hprof defined &quot;basic type&quot; for references." />
      <item value="Not thread safe, should be used from a single thread." />
      <item value="The Android Hprof format differs in some ways from that reference. This parser implementation is largely adapted from https:" />
      <item value="Binary Dump Format reference" />
      <item value="Binary Dump Format reference: http:hg.openjdk.java.netjdk6jdk6jdkraw-filetipsrcshare" />
      <item value="Reads hprof content from an Okio [BufferedSource]." />
      <item value="Removes {@code byteCount} bytes from this, decodes them as UTF-8, and returns the string." />
      <item value="Shark parsing file failed: null" />
      <item value="The array holding keys." />
      <item value="Code from com.carrotsearch.hppc.LongLongScatterMap copy pasted, inlined and converted to Kotlin." />
      <item value="Unknown tag 0x50 at -1056119298 after 0x21 at 2767887" />
      <item value="Length of the record or -1 if there is the length is not known" />
      <item value="Listener implementations are expected to read all bytes corresponding to a given tag from the provided reader before returning." />
      <item value="Executes the given [block] function on this resource and then closes it down correctly whether an exception is thrown or not." />
      <item value="How many bytes this reader has read from [source]. Can only increase." />
      <item value="Hprof is deprecated, and we offer partial backward compatibility. Any code that was previously using HprofReader directly now has to call [StreamingHprofReader.readerFor] or [HprofRandomAcccessReader.readerFor]" />
      <item value="Reads records in a Hprof source, one at a time with a specific position and size. Call [openReaderFor] to obtain a new instance." />
      <item value="Utility function to create a [OnHprofRecordTagListener] from the passed in [block] lambda instead of using the anonymous `object : OnHprofRecordTagListener` syntax." />
      <item value="Executes the given [block] function on this resource and then closes it down correctly whether an exception is thrown or not. @param block a function to process this [Closeable] resource. @return the result of [block] function invoked on this resource." />
      <item value="Opens a [CloseableHeapGraph] which you can use to navigate the indexed hprof and then close." />
      <item value="Searches the heap dump for leaking instances and then computes the shortest strong reference path from those instances to the GC roots." />
      <item value="filters" />
      <item value="@return the number of bytes read from the source" />
      <item value="Obtains a new source to read all hprof records from and calls [listener] back for each record that matches one of the provided [recordTags]." />
      <item value="First pass to count and correctly size arrays once and for all." />
      <item value="Creates a [StreamingHprofReader] that will call [StreamingSourceProvider.openStreamingSource] on every [readRecords] to obtain a [Source] to read the hprof data from. Before reading the hprof records, [StreamingHprofReader] will skip [HprofHeader.recordsPosition] bytes." />
    </histories>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1629022881998" />
  </component>
</application>